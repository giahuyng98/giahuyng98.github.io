{"componentChunkName":"component---src-templates-blog-post-js","path":"/week03/lsm-tree/","result":{"data":{"site":{"siteMetadata":{"title":"Blog"}},"markdownRemark":{"id":"b3f105c0-8f77-5498-8591-0d6b48bec789","excerpt":"source Flavors of IO Sector/Block/Page Sector size: 512\nBlock (1 group of adjacency sector) size: 512, 1024, 2048, 4096 bytes\nVirtual Memory Pages => File…","html":"<p><a href=\"https://medium.com/databasss/on-disk-io-part-3-lsm-trees-8b2da218496f\">source</a></p>\n<h1>Flavors of IO</h1>\n<h2>Sector/Block/Page</h2>\n<p>Sector size: 512\nBlock (1 group of adjacency sector) size: 512, 1024, 2048, 4096 bytes\n[Virtual Memory Pages] => [File System Block] => [Sector]</p>\n<h2>Standard IO</h2>\n<h2>Kernel Page cache</h2>\n<ul>\n<li>Read [Read request] => [Page cache] yes => Read, no => full ? LRU, read</li>\n<li>Write [Write request] => [Page cache] dirty page => flush/writeback => [IO queue]</li>\n<li>Page cache: Improve IO performent by delay write/read ahead (prefetch)</li>\n</ul>\n<h2>Direct IO</h2>\n<ul>\n<li>Không dùng kernel page cache, custom-IO…, </li>\n<li>Block alignment: starting offset multiple of 512 and buffer size multiple of 512</li>\n</ul>\n<h2>Memory Mapping</h2>\n<p>fsync\nmmap</p>\n<ul>\n<li>access file as if it was loaded in memory entirely</li>\n<li>mode private: allows reading, write trigger copy-on-write => changes private.</li>\n<li>mode shared: can see updates, <em>msync</em></li>\n<li>lazy load, memory mapping is done through the page cache</li>\n<li>can map with flags e.g read-only</li>\n<li>avoids creating an copy of the buffer in memory, avoids system call (and subsequent context switch)</li>\n</ul>\n<h2>Page cache optimizations</h2>\n<ul>\n<li>notify kernel access patterns</li>\n<li><code class=\"language-text\">FADV_SQEUENTIAL</code>,<code class=\"language-text\">FADV_RANDOM</code>,<code class=\"language-text\">FADV_WILLNEED</code>,<code class=\"language-text\">FADV_DONTNEED</code></li>\n<li><code class=\"language-text\">mlock</code>: force pages to be held in memory</li>\n</ul>\n<h2>AIO: Linux Asynchronous IO</h2>\n<ul>\n<li>Allowing multiple IO operations and register callbacks</li>\n</ul>\n<h2>Vectored IO (Scatter/Gather)</h2>\n<ul>\n<li>Allow reading/writing data to/from disk using multiple buffers per system call</li>\n</ul>\n<p>=> <code class=\"language-text\">each having own advantages and shortcomings</code></p>\n<h2>Mutable vs Immutable</h2>\n<ul>\n<li>Immutable: storage overhead can be minimized, don’t have to reserve any extra space</li>\n<li>Node splitting -> relocate written parts => Defragmentation</li>\n<li>In-place updates &#x3C;-> Mask as delete => garbage-collected</li>\n<li>Immutable: merge, rewrite files in order to make sure that the least amount of files is hit during the query.</li>\n<li>Mutable files: may have to rewritten partially/completely, merge overflow areas, reclaim space occupied by updated or deleted rocords.</li>\n</ul>\n<h1>LSM Tree</h1>\n<ul>\n<li>optimized for sequential disk access, node can have a full <em>occupancy</em></li>\n<li>allow imutable, mergeable files, primary index</li>\n</ul>\n<h2>Sorted string tables</h2>\n<ul>\n<li>persistent ordered immutable map</li>\n<li>easy to write, search and read.</li>\n<li>Index Block: quick lookup, holding offsets to the values in the data block</li>\n<li>Data Block: key/value pairs, fast sequential range scans</li>\n<li>Immutable => insert, update, delete => rewriting the whole file.</li>\n</ul>\n<h2>Anatomy</h2>\n<ul>\n<li>All the writes are performed against the mutable in-memory DS (log lookup).</li>\n<li>When the size of the tree reachs threshold or time period elapses => write to disk => new SSTable <em>flush</em></li>\n<li>Retrieving the data => searching all SSTables on disk => checking in-memory table => merge => result</li>\n<li>-</li>\n</ul>\n<h2>Compaction</h2>\n<ul>\n<li>Data growing, located in several files, multiple versions of the same record, redundant records that got shadowed by deletes. => reads will get more expensive</li>\n<li>Compaction: process read complete SSTables from disk and merge (because of sstable layout, very efficient).</li>\n</ul>\n<h2>Merge</h2>\n<ul>\n<li>Complexity as merging sorted.</li>\n<li>Use as compaction, read</li>\n</ul>\n<h2>Summarize</h2>\n<ul>\n<li>Better </li>\n</ul>","frontmatter":{"title":"LSM Tree","date":"July 28, 2020","description":"LSM Tree"}}},"pageContext":{"slug":"/week03/lsm-tree/","previous":{"fields":{"slug":"/week03/bloom-filter/"},"frontmatter":{"title":"Bloom Filter"}},"next":{"fields":{"slug":"/week03/oop/"},"frontmatter":{"title":"OOP"}}}}}